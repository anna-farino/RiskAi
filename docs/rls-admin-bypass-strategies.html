<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RLS Admin Bypass Strategies - Altair News Platform</title>

  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #2c3e50;
      background: #ffffff;
      padding: 40px 20px;
      max-width: 1000px;
      margin: 0 auto;
    }

    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px;
      border-radius: 12px;
      margin-bottom: 40px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .subtitle {
      font-size: 1.1em;
      opacity: 0.95;
      font-weight: 300;
    }

    h2 {
      color: #667eea;
      font-size: 1.8em;
      margin: 40px 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 3px solid #667eea;
      font-weight: 600;
    }

    h3 {
      color: #555;
      font-size: 1.4em;
      margin: 30px 0 15px 0;
      font-weight: 600;
    }

    h4 {
      color: #666;
      font-size: 1.1em;
      margin: 20px 0 10px 0;
      font-weight: 600;
    }

    p {
      margin-bottom: 15px;
      font-size: 1.05em;
      text-align: justify;
    }

    ul, ol {
      margin: 15px 0 15px 30px;
    }

    li {
      margin-bottom: 8px;
      font-size: 1.05em;
    }

    pre {
      background: #2d2d2d;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      page-break-inside: avoid;
    }

    code {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.9em;
    }

    .info-box {
      background: #e8f4f8;
      border-left: 4px solid #3498db;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
      page-break-inside: avoid;
    }

    .warning-box {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
      page-break-inside: avoid;
    }

    .success-box {
      background: #d4edda;
      border-left: 4px solid #28a745;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
      page-break-inside: avoid;
    }

    .danger-box {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
      page-break-inside: avoid;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      page-break-inside: avoid;
    }

    .comparison-table th {
      background: #667eea;
      color: white;
      padding: 15px;
      text-align: left;
      font-weight: 600;
    }

    .comparison-table td {
      padding: 12px 15px;
      border-bottom: 1px solid #ddd;
    }

    .comparison-table tr:nth-child(even) {
      background: #f8f9fa;
    }

    .pros-cons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    .pros, .cons {
      padding: 20px;
      border-radius: 8px;
    }

    .pros {
      background: #d4edda;
      border: 2px solid #28a745;
    }

    .cons {
      background: #f8d7da;
      border: 2px solid #dc3545;
    }

    .pros h4, .cons h4 {
      margin-top: 0;
      margin-bottom: 15px;
    }

    .pros h4 {
      color: #155724;
    }

    .cons h4 {
      color: #721c24;
    }

    .approach-card {
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 12px;
      padding: 30px;
      margin: 30px 0;
      page-break-inside: avoid;
    }

    .approach-title {
      font-size: 1.6em;
      color: #667eea;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .badge {
      display: inline-block;
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      margin-left: 10px;
    }

    .badge-recommended {
      background: #28a745;
      color: white;
    }

    .badge-warning {
      background: #ffc107;
      color: #333;
    }

    .flow-diagram {
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      font-family: monospace;
      font-size: 0.9em;
      line-height: 1.8;
      page-break-inside: avoid;
    }

    .verdict-box {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      margin: 40px 0;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      page-break-inside: avoid;
    }

    .verdict-box h2 {
      color: white;
      border-bottom: 3px solid white;
      margin-top: 0;
    }

    .verdict-box ul {
      margin-left: 20px;
    }

    .verdict-box li {
      margin-bottom: 10px;
    }

    /* PDF optimization */
    @media print {
      body {
        padding: 20px;
        font-size: 11pt;
      }

      header {
        background: #667eea !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      .info-box, .warning-box, .success-box, .danger-box,
      .approach-card, .verdict-box, .pros, .cons {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      pre {
        page-break-inside: avoid;
        background: #2d2d2d !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      h2, h3 {
        page-break-after: avoid;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>RLS Admin Bypass Strategies</h1>
    <div class="subtitle">Comparing Session Variables vs BYPASSRLS Role for Scalable Admin Operations</div>
    <div class="subtitle" style="margin-top: 10px; font-size: 0.9em;">Altair News Platform • Database Architecture</div>
  </header>

  <section>
    <h2>Executive Summary</h2>
    <p>
      This document compares two approaches for allowing the application to perform administrative database operations while maintaining Row Level Security (RLS) protection for regular users. The key challenge: as the platform scales to 50+ tables with RLS, we need a maintainable, secure, and performant solution for system-level operations like importing keywords from APIs without requiring a user_id.
    </p>

    <div class="success-box">
      <h4>Recommendation: Approach 2 (BYPASSRLS Role)</h4>
      <p>
        After analyzing scalability, maintainability, security, and performance, <strong>Approach 2 (BYPASSRLS Role with separate connection pool)</strong> is recommended. It provides a clean separation between user and admin operations, scales infinitely without per-table changes, and follows industry best practices used by platforms like Supabase.
      </p>
    </div>
  </section>

  <section>
    <h2>The Problem Context</h2>

    <h3>Current Situation</h3>
    <p>
      The <code>threat_keywords</code> table currently has RLS policies that require operations to either:
    </p>
    <ul>
      <li>Be performed by the keyword owner (user_id matches current_user_id)</li>
      <li>Access default keywords (is_default = true)</li>
    </ul>

    <p>Current RLS policy:</p>
    <pre><code class="language-typescript">pgPolicy('rls-threat-keywords', {
  for: 'all',
  using: sql`(
    user_id::text = current_setting('app.current_user_id', true)
    OR is_default = true
  )`,
  withCheck: sql`user_id::text = current_setting('app.current_user_id', true)`
})</code></pre>

    <h3>The Challenge</h3>
    <p>
      The application needs to create keywords from external APIs without a user context (no user_id). Additionally, this pattern will scale to <strong>all tables in the database</strong>—many of which will require admin-only operations for:
    </p>
    <ul>
      <li>Automated data imports from external APIs</li>
      <li>System maintenance and cleanup jobs</li>
      <li>Background schedulers and cron jobs</li>
      <li>Admin panel operations</li>
      <li>Database migrations and seeding</li>
    </ul>

    <div class="warning-box">
      <h4>Scalability Requirement</h4>
      <p>
        Eventually, <strong>all 50+ tables</strong> will have RLS policies. The solution must work universally without requiring individual policy updates for each table.
      </p>
    </div>
  </section>

  <section>
    <h2>Approach 1: Admin Session Variable</h2>
    <span class="badge badge-warning">NOT RECOMMENDED</span>

    <div class="approach-card">
      <div class="approach-title">Session Variable Pattern</div>
      <p>
        This approach uses PostgreSQL session variables to flag admin operations. Each RLS policy checks for an <code>app.is_admin</code> flag in addition to normal user checks.
      </p>
    </div>

    <h3>How It Works</h3>

    <h4>Step 1: Create Admin Context Function</h4>
    <pre><code class="language-typescript">// backend/db/with-admin-context.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pool } from "./db";

export async function withAdminContext&lt;T&gt;(
  fn: (db: ReturnType&lt;typeof drizzle&gt;) =&gt; Promise&lt;T&gt;,
  adminSecret?: string
): Promise&lt;T&gt; {
  // Optional: Verify admin secret from environment
  if (adminSecret !== process.env.APP_ADMIN_SECRET) {
    throw new Error('Invalid admin credentials');
  }

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    // Set session variable for this transaction
    await client.query(`SET LOCAL app.is_admin = 'true'`);

    const db = drizzle(client);
    const result = await fn(db);

    await client.query("COMMIT");
    return result;
  } catch (err) {
    await client.query("ROLLBACK");
    throw err;
  } finally {
    client.release();
  }
}</code></pre>

    <h4>Step 2: Update EVERY RLS Policy</h4>
    <pre><code class="language-typescript">// shared/db/schema/threat-tracker/index.ts
export const threatKeywords = pgTable("threat_keywords", {
  id: uuid("id").defaultRandom().primaryKey(),
  term: text("term").notNull(),
  category: text("category").notNull(),
  userId: uuid("user_id").references(() => users.id),
  isDefault: boolean("is_default").notNull().default(false),
}, (_t) => [
  pgPolicy('rls-threat-keywords', {
    for: 'all',
    using: sql`(
      user_id::text = current_setting('app.current_user_id', true)
      OR is_default = true
      OR current_setting('app.is_admin', true) = 'true'
    )`,
    withCheck: sql`(
      user_id::text = current_setting('app.current_user_id', true)
      OR current_setting('app.is_admin', true) = 'true'
    )`
  })
]);</code></pre>

    <h4>Step 3: Usage in Application Code</h4>
    <pre><code class="language-typescript">// Example: Import keywords from API
import { withAdminContext } from './db/with-admin-context';

async function importKeywordsFromAPI() {
  const apiKeywords = await fetchFromExternalAPI();

  await withAdminContext(async (db) => {
    await db.insert(threatKeywords).values(
      apiKeywords.map(kw => ({
        term: kw.term,
        category: kw.category,
        userId: null,
        isDefault: true
      }))
    );
  }, process.env.APP_ADMIN_SECRET);
}</code></pre>

    <h3>Security Flow</h3>
    <div class="flow-diagram">
API Call → Backend Handler → Verify APP_ADMIN_SECRET
                                      ↓
                              withAdminContext()
                                      ↓
                          SET LOCAL app.is_admin='true'
                                      ↓
                          Execute DB operation
                                      ↓
              RLS Policy: Check app.is_admin=true ✓
                                      ↓
                      COMMIT (session vars destroyed)
    </div>

    <h3>Detailed Analysis</h3>

    <div class="pros-cons">
      <div class="pros">
        <h4>✓ Pros</h4>
        <ul>
          <li><strong>Granular control:</strong> Can selectively enable admin access per table</li>
          <li><strong>No database schema changes:</strong> Just update RLS policies</li>
          <li><strong>Secure:</strong> Session variables auto-destroyed after transaction</li>
          <li><strong>Follows existing pattern:</strong> Similar to current <code>withUserContext()</code></li>
          <li><strong>No additional credentials:</strong> Uses existing database connection</li>
        </ul>
      </div>

      <div class="cons">
        <h4>✗ Cons</h4>
        <ul>
          <li><strong>High maintenance:</strong> Must update RLS policy for ALL 50+ tables</li>
          <li><strong>Error-prone:</strong> Easy to forget admin check in new tables</li>
          <li><strong>Repetitive code:</strong> Same OR clause in every policy</li>
          <li><strong>Performance overhead:</strong> Extra RLS check on every query</li>
          <li><strong>Not scalable:</strong> Becomes unmanageable with many tables</li>
        </ul>
      </div>
    </div>

    <div class="danger-box">
      <h4>Critical Scalability Issue</h4>
      <p>
        With 50+ tables, you'll need to manually add <code>OR current_setting('app.is_admin', true) = 'true'</code> to every single RLS policy. This becomes unmaintainable and is prone to human error when new tables are added.
      </p>
    </div>
  </section>

  <section>
    <h2>Approach 2: BYPASSRLS Role with Separate Connection Pool</h2>
    <span class="badge badge-recommended">RECOMMENDED</span>

    <div class="approach-card">
      <div class="approach-title">Dedicated Admin Database Role</div>
      <p>
        This approach creates a separate PostgreSQL role with BYPASSRLS privilege and uses a dedicated connection pool for admin operations. Admin operations completely bypass RLS, while user operations continue to be protected.
      </p>
    </div>

    <h3>How It Works</h3>

    <h4>Step 1: Create Admin Role (One-Time Setup)</h4>
    <pre><code class="language-sql">-- Run once in your PostgreSQL database
CREATE ROLE app_admin WITH
  LOGIN
  BYPASSRLS
  PASSWORD 'your_strong_password_from_env';

-- Grant necessary permissions
GRANT CONNECT ON DATABASE altair_db TO app_admin;
GRANT USAGE ON SCHEMA public TO app_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_admin;

-- Ensure future tables also grant permissions
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO app_admin;</code></pre>

    <h4>Step 2: Create Admin Connection Pool</h4>
    <pre><code class="language-typescript">// backend/db/admin-db.ts
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';

export const adminPool = new Pool({
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  user: process.env.DB_ADMIN_USER,        // 'app_admin'
  password: process.env.DB_ADMIN_PASSWORD, // Strong password
  max: 5,                                  // Smaller pool for admin ops
});

export const adminDb = drizzle(adminPool);</code></pre>

    <h4>Step 3: Create Admin Context Function</h4>
    <pre><code class="language-typescript">// backend/db/with-admin-context.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { adminPool } from "./admin-db";

export async function withAdminContext&lt;T&gt;(
  fn: (db: ReturnType&lt;typeof drizzle&gt;) =&gt; Promise&lt;T&gt;,
  options?: { requireSecret?: string }
): Promise&lt;T&gt; {
  // Optional: Verify secret at application layer
  if (options?.requireSecret &&
      options.requireSecret !== process.env.APP_ADMIN_SECRET) {
    throw new Error('Unauthorized admin operation');
  }

  const client = await adminPool.connect();
  try {
    await client.query("BEGIN");

    const db = drizzle(client);
    const result = await fn(db);

    await client.query("COMMIT");
    return result;
  } catch (err) {
    await client.query("ROLLBACK");
    throw err;
  } finally {
    client.release();
  }
}</code></pre>

    <h4>Step 4: Environment Variables</h4>
    <pre><code class="language-bash"># .env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=altair_db
DB_USER=app_user              # Regular user (RLS enforced)
DB_PASSWORD=user_password

DB_ADMIN_USER=app_admin        # Admin user (BYPASSRLS)
DB_ADMIN_PASSWORD=admin_strong_password

APP_ADMIN_SECRET=your_secret_key_for_app_layer_auth</code></pre>

    <h4>Step 5: Usage in Application Code</h4>
    <pre><code class="language-typescript">// Example: Import keywords from API
import { withAdminContext } from './db/with-admin-context';

async function importKeywordsFromAPI() {
  const apiKeywords = await fetchFromExternalAPI();

  // Bypasses ALL RLS automatically
  await withAdminContext(async (db) => {
    await db.insert(threatKeywords).values(
      apiKeywords.map(kw => ({
        term: kw.term,
        category: kw.category,
        userId: null,
        isDefault: true
      }))
    );
  }, { requireSecret: process.env.APP_ADMIN_SECRET });
}

// Example: Admin panel operations
async function deleteExpiredData() {
  await withAdminContext(async (db) => {
    // Can operate on ANY table without RLS restrictions
    await db.delete(threatArticles)
      .where(lt(threatArticles.scrapeDate, thirtyDaysAgo));

    await db.delete(oldReports)
      .where(lt(reports.createdAt, oneYearAgo));
  }, { requireSecret: process.env.APP_ADMIN_SECRET });
}</code></pre>

    <h4>Step 6: Keep Existing User Context (No Changes)</h4>
    <pre><code class="language-typescript">// Regular user operations continue to use withUserContext
// backend/db/with-user-context.ts (UNCHANGED)

export async function withUserContext&lt;T&gt;(
  userId: string,
  fn: (db: ReturnType&lt;typeof drizzle&gt;) =&gt; Promise&lt;T&gt;
): Promise&lt;T&gt; {
  const client = await pool.connect();  // Uses regular pool
  try {
    await client.query("BEGIN");
    await client.query(`SET LOCAL app.current_user_id = '${userId}'`);

    const db = drizzle(client);
    const result = await fn(db);

    await client.query("COMMIT");
    return result;
  } catch (err) {
    await client.query("ROLLBACK");
    throw err;
  } finally {
    client.release();
  }
}</code></pre>

    <h3>Architecture Diagram</h3>
    <div class="flow-diagram">
┌─────────────────────────────────────────────┐
│         Application Layer                   │
├─────────────────────────────────────────────┤
│                                             │
│  User Operations    │    Admin Operations  │
│  (via API)          │    (via Schedulers)  │
│        ↓            │           ↓          │
│  withUserContext()  │  withAdminContext()  │
│        ↓            │           ↓          │
├─────────────────────┴───────────────────────┤
│                                             │
│  Regular Pool       │    Admin Pool        │
│  (app_user)         │    (app_admin)       │
│  RLS: ✓ ENFORCED    │    RLS: ✗ BYPASSED   │
│        ↓            │           ↓          │
└─────────┴───────────┴───────────┴───────────┘
          │                       │
          └───────────┬───────────┘
                      ↓
          ┌───────────────────────┐
          │  PostgreSQL Database  │
          │  (All 50+ Tables)     │
          └───────────────────────┘
    </div>

    <h3>Detailed Analysis</h3>

    <div class="pros-cons">
      <div class="pros">
        <h4>✓ Pros</h4>
        <ul>
          <li><strong>Zero per-table maintenance:</strong> Works with ALL current and future tables</li>
          <li><strong>Perfectly scalable:</strong> Add 100 tables, admin access just works</li>
          <li><strong>Clear separation:</strong> Admin vs user operations use different pools</li>
          <li><strong>Industry standard:</strong> Pattern used by Supabase, AWS RDS, etc.</li>
          <li><strong>Better performance:</strong> No RLS overhead on admin operations</li>
          <li><strong>Easy to audit:</strong> Search codebase for <code>withAdminContext</code> calls</li>
          <li><strong>Flexible security:</strong> Can add application-layer auth checks</li>
          <li><strong>Future-proof:</strong> No code changes as schema evolves</li>
        </ul>
      </div>

      <div class="cons">
        <h4>✗ Cons</h4>
        <ul>
          <li><strong>Additional credentials:</strong> Need to manage admin password (but already managing DB password)</li>
          <li><strong>Slightly more setup:</strong> Create role + connection pool (one-time)</li>
          <li><strong>Bypasses ALL RLS:</strong> Not granular per-table (but this is intentional for admin ops)</li>
        </ul>
      </div>
    </div>

    <h3>Security Deep Dive</h3>

    <div class="info-box">
      <h4>Is Bypassing All RLS Safe?</h4>
      <p>
        <strong>Yes, for admin operations.</strong> The key insight is that admin operations are <em>intentionally privileged</em>. Security comes from:
      </p>
      <ul>
        <li><strong>Credential protection:</strong> Admin credentials only in environment variables (server-side)</li>
        <li><strong>Application-layer auth:</strong> <code>requireSecret</code> parameter prevents unauthorized calls</li>
        <li><strong>Code review:</strong> All <code>withAdminContext</code> calls visible in codebase</li>
        <li><strong>Audit logging:</strong> Can add logging to <code>withAdminContext</code> function</li>
        <li><strong>Network security:</strong> Database not exposed to internet</li>
      </ul>
    </div>

    <h4>Attack Vector Analysis</h4>
    <table class="comparison-table">
      <thead>
        <tr>
          <th>Attack Vector</th>
          <th>Risk Level</th>
          <th>Mitigation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>SQL Injection</td>
          <td>✅ None</td>
          <td>Using parameterized queries via Drizzle ORM</td>
        </tr>
        <tr>
          <td>Credential Leak (env vars)</td>
          <td>⚠️ Low</td>
          <td>Same risk as regular DB password; server-side only</td>
        </tr>
        <tr>
          <td>Unauthorized Admin Call</td>
          <td>✅ None</td>
          <td><code>requireSecret</code> parameter verifies APP_ADMIN_SECRET</td>
        </tr>
        <tr>
          <td>Code Injection</td>
          <td>✅ None</td>
          <td>If attacker has code execution, system already compromised</td>
        </tr>
        <tr>
          <td>Network Interception</td>
          <td>✅ None</td>
          <td>Database connections use SSL/TLS</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Side-by-Side Comparison</h2>

    <table class="comparison-table">
      <thead>
        <tr>
          <th>Criterion</th>
          <th>Approach 1: Session Variable</th>
          <th>Approach 2: BYPASSRLS Role</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Scalability</strong></td>
          <td>❌ Poor - Must update every RLS policy</td>
          <td>✅ Excellent - Zero per-table changes</td>
        </tr>
        <tr>
          <td><strong>Maintenance</strong></td>
          <td>❌ High - 50+ policies to maintain</td>
          <td>✅ Low - One-time setup</td>
        </tr>
        <tr>
          <td><strong>Error Prone</strong></td>
          <td>❌ Yes - Easy to forget admin check</td>
          <td>✅ No - Works automatically</td>
        </tr>
        <tr>
          <td><strong>Performance</strong></td>
          <td>⚠️ Medium - RLS overhead on admin ops</td>
          <td>✅ High - No RLS evaluation</td>
        </tr>
        <tr>
          <td><strong>Security</strong></td>
          <td>✅ Good - Session-based</td>
          <td>✅ Good - Credential-based</td>
        </tr>
        <tr>
          <td><strong>Code Clarity</strong></td>
          <td>⚠️ Medium - Repetitive policy code</td>
          <td>✅ High - Clear admin/user separation</td>
        </tr>
        <tr>
          <td><strong>Industry Adoption</strong></td>
          <td>⚠️ Less common</td>
          <td>✅ Standard pattern (Supabase, AWS)</td>
        </tr>
        <tr>
          <td><strong>Auditability</strong></td>
          <td>⚠️ Medium - Check each policy</td>
          <td>✅ High - Search for withAdminContext</td>
        </tr>
        <tr>
          <td><strong>Initial Setup</strong></td>
          <td>✅ Simple - Just add function</td>
          <td>⚠️ Medium - Create role + pool</td>
        </tr>
        <tr>
          <td><strong>Future Changes</strong></td>
          <td>❌ High - Update all new table policies</td>
          <td>✅ None - Automatic for new tables</td>
        </tr>
      </tbody>
    </table>

    <h3>Real-World Scenario: Adding 10 New Tables</h3>

    <h4>Approach 1 (Session Variable)</h4>
    <pre><code class="language-typescript">// Must manually update RLS for EACH new table:

// Table 1
pgPolicy('rls-table1', {
  using: sql`... OR current_setting('app.is_admin', true) = 'true'`
})

// Table 2
pgPolicy('rls-table2', {
  using: sql`... OR current_setting('app.is_admin', true) = 'true'`
})

// Table 3... Table 4... Table 5... (repeat 10 times)
// Forget once = security hole or broken admin functionality</code></pre>

    <h4>Approach 2 (BYPASSRLS Role)</h4>
    <pre><code class="language-typescript">// Add 10 new tables with RLS policies
// Admin access works automatically, zero changes needed

// All admin operations just work:
await withAdminContext(async (db) => {
  await db.insert(newTable1).values([...]);
  await db.insert(newTable2).values([...]);
  await db.update(newTable3).set({...});
  // No policy updates needed!
});</code></pre>

    <div class="success-box">
      <h4>Winner: Approach 2</h4>
      <p>
        With Approach 2, adding new tables requires <strong>zero admin-related changes</strong>. With Approach 1, you must remember to update the RLS policy for every single table.
      </p>
    </div>
  </section>

  <section>
    <h2>Performance Considerations</h2>

    <h3>RLS Evaluation Overhead</h3>
    <p>
      Every RLS policy is evaluated for <strong>every row</strong> during query execution. This includes checking session variables with <code>current_setting()</code>.
    </p>

    <h4>Approach 1: Additional RLS Check Per Row</h4>
    <pre><code class="language-sql">-- For EVERY row, PostgreSQL evaluates:
user_id::text = current_setting('app.current_user_id', true)
OR is_default = true
OR current_setting('app.is_admin', true) = 'true'  -- Extra check!

-- With 10,000 keywords and 50 tables:
-- = 500,000 additional function calls per full scan</code></pre>

    <h4>Approach 2: Zero RLS Overhead</h4>
    <pre><code class="language-sql">-- Admin operations bypass RLS entirely
-- No policy evaluation at all
-- Direct data access like table owner</code></pre>

    <div class="info-box">
      <h4>Benchmark Impact</h4>
      <p>
        While the overhead is small per query, with 50+ tables and frequent admin operations (schedulers, imports, cleanup jobs), Approach 2 provides measurably better performance by eliminating unnecessary RLS evaluation on admin queries.
      </p>
    </div>
  </section>

  <section>
    <h2>Implementation Roadmap</h2>

    <h3>Phase 1: Database Setup (5 minutes)</h3>
    <ol>
      <li>Create <code>app_admin</code> role with BYPASSRLS privilege</li>
      <li>Grant necessary permissions</li>
      <li>Add environment variables for admin credentials</li>
    </ol>

    <h3>Phase 2: Application Code (15 minutes)</h3>
    <ol>
      <li>Create <code>backend/db/admin-db.ts</code> with admin connection pool</li>
      <li>Create <code>backend/db/with-admin-context.ts</code> function</li>
      <li>Add <code>APP_ADMIN_SECRET</code> to environment</li>
    </ol>

    <h3>Phase 3: Migration (30 minutes)</h3>
    <ol>
      <li>Identify existing code that needs admin operations</li>
      <li>Replace direct DB calls with <code>withAdminContext()</code></li>
      <li>Test admin operations (keyword import, schedulers, etc.)</li>
      <li>Verify user operations still work with RLS</li>
    </ol>

    <h3>Phase 4: Monitoring & Audit (Ongoing)</h3>
    <ol>
      <li>Add logging to <code>withAdminContext()</code> function</li>
      <li>Monitor admin pool usage</li>
      <li>Review <code>withAdminContext</code> calls during code reviews</li>
    </ol>

    <div class="success-box">
      <h4>Total Time Investment: ~1 hour</h4>
      <p>
        One-time setup that eliminates the need for maintaining 50+ RLS policies and provides infinite scalability.
      </p>
    </div>
  </section>

  <section>
    <h2>Optional Enhancement: Audit Logging</h2>

    <p>
      For maximum security and observability, add audit logging to the admin context:
    </p>

    <pre><code class="language-typescript">// backend/db/with-admin-context.ts (Enhanced)
import { drizzle } from "drizzle-orm/node-postgres";
import { adminPool } from "./admin-db";
import { auditLogs } from "@shared/db/schema/audit";

export async function withAdminContext&lt;T&gt;(
  fn: (db: ReturnType&lt;typeof drizzle&gt;) =&gt; Promise&lt;T&gt;,
  options?: {
    requireSecret?: string,
    operation?: string,  // Description of operation
    metadata?: Record&lt;string, any&gt;
  }
): Promise&lt;T&gt; {
  if (options?.requireSecret &&
      options.requireSecret !== process.env.APP_ADMIN_SECRET) {
    throw new Error('Unauthorized admin operation');
  }

  const client = await adminPool.connect();
  const startTime = Date.now();

  try {
    await client.query("BEGIN");

    const db = drizzle(client);
    const result = await fn(db);

    // Log successful admin operation
    await db.insert(auditLogs).values({
      action: 'admin_operation',
      operation: options?.operation || 'unknown',
      status: 'success',
      duration: Date.now() - startTime,
      metadata: options?.metadata,
      timestamp: new Date()
    });

    await client.query("COMMIT");
    return result;
  } catch (err) {
    // Log failed admin operation
    await client.query("ROLLBACK");

    console.error('Admin operation failed:', {
      operation: options?.operation,
      error: err.message,
      duration: Date.now() - startTime
    });

    throw err;
  } finally {
    client.release();
  }
}</code></pre>

    <p>Usage with audit logging:</p>
    <pre><code class="language-typescript">await withAdminContext(async (db) => {
  await db.insert(threatKeywords).values([...]);
}, {
  requireSecret: process.env.APP_ADMIN_SECRET,
  operation: 'import_keywords_from_api',
  metadata: { source: 'mitre_attack', count: 150 }
});</code></pre>
  </section>

  <section>
    <div class="verdict-box">
      <h2>Final Verdict: Approach 2 (BYPASSRLS Role)</h2>

      <h3>Why Approach 2 is the Clear Winner</h3>
      <ul>
        <li><strong>Infinite Scalability:</strong> Works automatically with all current and future tables</li>
        <li><strong>Zero Maintenance:</strong> No per-table RLS policy updates required</li>
        <li><strong>Better Performance:</strong> No RLS evaluation overhead on admin operations</li>
        <li><strong>Industry Standard:</strong> Pattern used by Supabase, AWS, and major platforms</li>
        <li><strong>Clear Architecture:</strong> Explicit separation between user and admin operations</li>
        <li><strong>Easy to Audit:</strong> All admin operations searchable via <code>withAdminContext</code></li>
        <li><strong>Future-Proof:</strong> Schema changes don't require admin access code changes</li>
        <li><strong>Secure:</strong> Credentials in environment variables + optional app-layer auth</li>
      </ul>

      <h3>The Key Insight</h3>
      <p>
        Admin operations <strong>should</strong> bypass RLS—that's what makes them admin operations. Security comes from protecting <em>who can call admin operations</em> (application-layer authorization + environment secrets), not from database policies.
      </p>

      <h3>Implementation Priority</h3>
      <p>
        <strong>High priority.</strong> With the platform scaling to 50+ tables with RLS, implementing this pattern now will save significant maintenance overhead and prevent future technical debt.
      </p>
    </div>
  </section>

  <section style="margin-top: 40px; padding-top: 30px; border-top: 3px solid #dee2e6;">
    <p style="text-align: center; color: #6c757d; font-size: 0.95em;">
      <strong>Altair News Platform</strong> • RLS Admin Bypass Architecture • January 2025
    </p>
  </section>
</body>
</html>