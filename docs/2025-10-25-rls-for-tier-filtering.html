<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025-10-25: RLS for Tier-Based Source Filtering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 8px;
        }

        .approach-card {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 25px;
            margin: 25px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .approach-card.winner {
            border-left: 4px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #f1f9f4 100%);
        }

        .approach-card h3 {
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            background: #28a745;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .badge.warning {
            background: #ffc107;
            color: #333;
        }

        .badge.danger {
            background: #dc3545;
        }

        .badge.info {
            background: #17a2b8;
        }

        .pros {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .cons {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .recommendation {
            background: linear-gradient(135deg, #667eea22 0%, #764ba222 100%);
            border: 2px solid #667eea;
            padding: 30px;
            margin: 30px 0;
            border-radius: 8px;
        }

        .recommendation h3 {
            color: #667eea;
            margin-top: 0;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #c7254e;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 15px 0;
            line-height: 1.5;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .keyword { color: #66d9ef; }
        .string { color: #a6e22e; }
        .comment { color: #75715e; font-style: italic; }
        .function { color: #e6db74; }
        .number { color: #ae81ff; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
            vertical-align: top;
        }

        table tr:hover {
            background: #f5f5f5;
        }

        table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .note strong {
            color: #856404;
        }

        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .warning strong {
            color: #721c24;
        }

        .security-box {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .security-box h4 {
            color: #0c5460;
            margin-top: 0;
        }

        .diagram {
            background: white;
            border: 2px solid #e1e4e8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .layer {
            margin: 15px 0;
            padding: 15px;
            border-radius: 4px;
        }

        .layer.db {
            background: #e8f4f8;
            border-left: 4px solid #17a2b8;
        }

        .layer.app {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .layer.both {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            padding: 20px;
            border-radius: 6px;
            border: 2px solid #e1e4e8;
        }

        .comparison-card.app {
            background: #d4edda22;
            border-color: #28a745;
        }

        .comparison-card.rls {
            background: #e8f4f822;
            border-color: #17a2b8;
        }

        .comparison-card h4 {
            margin-top: 0;
        }

        footer {
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            color: #666;
            border-top: 1px solid #ddd;
        }

        .implementation-section {
            background: white;
            border: 2px solid #e1e4e8;
            padding: 25px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .implementation-section h4 {
            color: #667eea;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîí RLS for Tier-Based Source Filtering</h1>
            <p class="subtitle">Should You Use Row Level Security? Analysis & Best Practices</p>
        </header>

        <div class="content">
            <h2>ü§î The Question</h2>
            <p>You're already using RLS for <code>keywords</code> and <code>threat_keywords</code>. Should you also apply RLS to <code>global_sources</code> for tier-based filtering?</p>

            <div class="note">
                <strong>Current State:</strong> You have RLS policies on user-owned data (keywords), but <code>global_sources</code> is shared data accessed via preferences table.
            </div>

            <h2>üìä Understanding RLS in Your Context</h2>

            <div class="diagram">
                <div style="text-align: center; margin-bottom: 20px; font-weight: bold; color: #667eea;">
                    Current Architecture
                </div>

                <div class="layer db">
                    <strong>üîí RLS Protected (User-Owned Data)</strong>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><code>keywords</code> - User's custom keywords (RLS: user_id match)</li>
                        <li><code>threat_keywords</code> - User + default keywords (RLS: user_id OR is_default)</li>
                    </ul>
                </div>

                <div class="layer app">
                    <strong>üåê No RLS (Global/Shared Data)</strong>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><code>global_sources</code> - Shared across all users</li>
                        <li><code>user_source_preferences</code> - User's selections (has user_id)</li>
                    </ul>
                </div>
            </div>

            <h2>‚öñÔ∏è RLS vs Application-Level Filtering</h2>

            <div class="comparison-grid">
                <div class="comparison-card app">
                    <h4>üèóÔ∏è Application-Level Filtering</h4>
                    <p><strong>How it works:</strong></p>
                    <ul>
                        <li>Filter in application code</li>
                        <li>Use WHERE clauses in queries</li>
                        <li>Manual tier checks</li>
                    </ul>
                    <pre><code><span class="comment">// Application filters</span>
<span class="keyword">const</span> sources = <span class="keyword">await</span> db
  .<span class="function">select</span>()
  .<span class="function">from</span>(globalSources)
  .<span class="function">where</span>(<span class="function">lte</span>(
    globalSources.requiredTierLevel,
    userTierLevel
  ));</code></pre>
                </div>

                <div class="comparison-card rls">
                    <h4>üîí Row Level Security (RLS)</h4>
                    <p><strong>How it works:</strong></p>
                    <ul>
                        <li>Database enforces automatically</li>
                        <li>Applies to ALL queries</li>
                        <li>No code needed</li>
                    </ul>
                    <pre><code><span class="comment">-- DB auto-filters</span>
<span class="keyword">CREATE POLICY</span> tier_filter
  <span class="keyword">ON</span> global_sources
  <span class="keyword">USING</span> (
    required_tier_level &lt;=
    get_user_tier_level()
  );</code></pre>
                </div>
            </div>

            <h2>üéØ Should You Use RLS for Global Sources?</h2>

            <div class="approach-card">
                <h3>‚ùå Option 1: No RLS (Current Approach) <span class="badge info">Current</span></h3>
                <p><strong>How it works:</strong> <code>global_sources</code> is a shared table. Users access sources through <code>user_source_preferences</code> junction table. Tier filtering done in application code.</p>

                <pre><code><span class="comment">// No RLS policy - application handles filtering</span>
<span class="keyword">export const</span> globalSources = <span class="function">pgTable</span>(<span class="string">'global_sources'</span>, {
  id: <span class="function">uuid</span>(<span class="string">'id'</span>).<span class="function">primaryKey</span>(),
  name: <span class="function">text</span>(<span class="string">'name'</span>).<span class="function">notNull</span>(),
  requiredTierLevel: <span class="function">integer</span>(<span class="string">'required_tier_level'</span>).<span class="function">default</span>(<span class="number">0</span>),
  <span class="comment">// No userId - shared data!</span>
});</code></pre>

                <div class="pros">
                    <strong>‚úÖ Pros:</strong>
                    <ul>
                        <li><strong>Simpler architecture:</strong> Sources are truly global, not user-scoped</li>
                        <li><strong>Flexible queries:</strong> Can easily query all sources for admin views</li>
                        <li><strong>No RLS overhead:</strong> Slightly faster queries (no policy evaluation)</li>
                        <li><strong>Explicit control:</strong> You know exactly when filtering happens</li>
                        <li><strong>Easier debugging:</strong> Can see all sources in DB queries</li>
                        <li><strong>Admin operations:</strong> Can manage sources without bypassing RLS</li>
                    </ul>
                </div>

                <div class="cons">
                    <strong>‚ùå Cons:</strong>
                    <ul>
                        <li>Must remember to filter in every query (risk of forgetting)</li>
                        <li>No database-level enforcement</li>
                        <li>Developer could accidentally expose higher-tier sources</li>
                    </ul>
                </div>
            </div>

            <div class="approach-card">
                <h3>‚ö†Ô∏è Option 2: RLS with Session Variable <span class="badge warning">Problematic</span></h3>
                <p><strong>How it works:</strong> Set user's tier level as PostgreSQL session variable, use in RLS policy.</p>

                <pre><code><span class="comment">-- Set session variable before queries</span>
<span class="keyword">SET LOCAL</span> app.user_tier_level = <span class="string">'1'</span>;

<span class="comment">-- RLS policy uses session variable</span>
<span class="keyword">CREATE POLICY</span> tier_based_access
  <span class="keyword">ON</span> global_sources
  <span class="keyword">FOR SELECT USING</span> (
    required_tier_level &lt;=
    <span class="function">current_setting</span>(<span class="string">'app.user_tier_level'</span>, <span class="keyword">true</span>)::<span class="keyword">integer</span>
  );</code></pre>

                <div class="pros">
                    <strong>‚úÖ Pros:</strong>
                    <ul>
                        <li>Automatic enforcement on all queries</li>
                        <li>Can't forget to filter</li>
                        <li>Defense in depth</li>
                    </ul>
                </div>

                <div class="cons">
                    <strong>‚ùå Cons:</strong>
                    <ul>
                        <li><strong>Connection pooling issues:</strong> Session variables can persist across requests</li>
                        <li><strong>Must set before EVERY query:</strong> Extra overhead</li>
                        <li><strong>Admin queries broken:</strong> Need to disable RLS for management</li>
                        <li><strong>Complex subqueries:</strong> Hard to query sources for different users</li>
                        <li><strong>Testing complexity:</strong> Must mock session variables</li>
                    </ul>
                </div>

                <div class="warning">
                    <strong>‚ö†Ô∏è Connection Pool Danger:</strong> In connection pooling (like with Neon, Supabase, PgBouncer), session variables can leak between requests. User A's tier level might accidentally apply to User B's query!
                </div>
            </div>

            <div class="approach-card winner">
                <h3>‚úÖ Option 3: Hybrid - Application Filtering + Security Audit <span class="badge">RECOMMENDED</span></h3>
                <p><strong>How it works:</strong> Keep application-level filtering, but add <strong>defense-in-depth</strong> with a helper function that validates access.</p>

                <div class="security-box">
                    <h4>üõ°Ô∏è Defense in Depth Strategy</h4>
                    <p>Instead of relying solely on RLS or solely on application code, create a <strong>mandatory validation layer</strong> that acts as a safety net.</p>
                </div>

                <pre><code><span class="comment">// backend/utils/tier-filtering.ts</span>

<span class="comment">/**
 * SECURITY: Always use this function to fetch sources
 * Never query global_sources directly in endpoints
 */</span>
<span class="keyword">export async function</span> <span class="function">getSourcesForUser</span>(
  userId: <span class="keyword">string</span>
): <span class="keyword">Promise</span>&lt;GlobalSource[]&gt; {
  <span class="keyword">const</span> userTierLevel = <span class="keyword">await</span> <span class="function">getUserTierLevel</span>(userId);

  <span class="comment">// Application-level filtering (fast, explicit)</span>
  <span class="keyword">const</span> sources = <span class="keyword">await</span> db
    .<span class="function">select</span>()
    .<span class="function">from</span>(globalSources)
    .<span class="function">where</span>(
      <span class="function">and</span>(
        <span class="function">eq</span>(globalSources.isActive, <span class="keyword">true</span>),
        <span class="function">lte</span>(globalSources.requiredTierLevel, userTierLevel)
      )
    );

  <span class="keyword">return</span> sources;
}

<span class="comment">/**
 * SECURITY: Validate before allowing source enable
 */</span>
<span class="keyword">export async function</span> <span class="function">validateSourceAccess</span>(
  userId: <span class="keyword">string</span>,
  sourceId: <span class="keyword">string</span>
): <span class="keyword">Promise</span>&lt;{ allowed: <span class="keyword">boolean</span>; reason?: <span class="keyword">string</span> }&gt; {
  <span class="keyword">const</span> userTierLevel = <span class="keyword">await</span> <span class="function">getUserTierLevel</span>(userId);

  <span class="keyword">const</span> [source] = <span class="keyword">await</span> db
    .<span class="function">select</span>()
    .<span class="function">from</span>(globalSources)
    .<span class="function">where</span>(<span class="function">eq</span>(globalSources.id, sourceId));

  <span class="keyword">if</span> (!source) {
    <span class="keyword">return</span> { allowed: <span class="keyword">false</span>, reason: <span class="string">'Source not found'</span> };
  }

  <span class="keyword">if</span> (source.requiredTierLevel > userTierLevel) {
    <span class="keyword">return</span> {
      allowed: <span class="keyword">false</span>,
      reason: <span class="string">`Requires tier level ${source.requiredTierLevel}`</span>
    };
  }

  <span class="keyword">return</span> { allowed: <span class="keyword">true</span> };
}</code></pre>

                <h4>Enforcement Through Code Review + Linting</h4>
                <pre><code><span class="comment">// .eslintrc.js - Custom rule</span>
{
  <span class="string">"rules"</span>: {
    <span class="string">"no-restricted-syntax"</span>: [
      <span class="string">"error"</span>,
      {
        <span class="string">"selector"</span>: <span class="string">"CallExpression[callee.property.name='from'][arguments.0.name='globalSources']"</span>,
        <span class="string">"message"</span>: <span class="string">"‚õî Use getSourcesForUser() instead of querying globalSources directly"</span>
      }
    ]
  }
}</code></pre>

                <div class="pros">
                    <strong>‚úÖ Best of Both Worlds:</strong>
                    <ul>
                        <li><strong>Application control:</strong> Fast, flexible, explicit filtering</li>
                        <li><strong>Mandatory helpers:</strong> Can't query sources without going through validation</li>
                        <li><strong>ESLint enforcement:</strong> Prevents direct queries to global_sources</li>
                        <li><strong>Admin flexibility:</strong> Can still query all sources when needed</li>
                        <li><strong>No pool issues:</strong> No session variable complications</li>
                        <li><strong>Clear audit trail:</strong> All access goes through logged functions</li>
                        <li><strong>Testable:</strong> Easy to unit test validation logic</li>
                    </ul>
                </div>

                <div class="note">
                    <strong>üéØ Key Insight:</strong> For <strong>shared/global data</strong> (like sources), application-level filtering with mandatory helper functions is superior to RLS. RLS shines for <strong>user-owned data</strong> (like keywords).
                </div>
            </div>

            <h2>üé® When to Use RLS vs Application Filtering</h2>

            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Use RLS</th>
                        <th>Use Application Filtering</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>User-Owned Data</strong><br>(keywords, user settings)</td>
                        <td>‚úÖ Perfect fit<br>Each row belongs to one user</td>
                        <td>‚ö†Ô∏è Works but redundant<br>RLS is simpler</td>
                    </tr>
                    <tr>
                        <td><strong>Shared Data with Access Rules</strong><br>(global sources by tier)</td>
                        <td>‚ö†Ô∏è Problematic<br>Session variable complexity</td>
                        <td>‚úÖ Better choice<br>Cleaner, more flexible</td>
                    </tr>
                    <tr>
                        <td><strong>Multi-Tenant Strict Isolation</strong><br>(Org A can't see Org B)</td>
                        <td>‚úÖ Excellent<br>Database-level isolation</td>
                        <td>‚ö†Ô∏è Risky<br>Could forget filter</td>
                    </tr>
                    <tr>
                        <td><strong>Public/Global Data</strong><br>(public articles, categories)</td>
                        <td>‚ùå Not needed<br>No access control</td>
                        <td>N/A<br>No filtering needed</td>
                    </tr>
                    <tr>
                        <td><strong>Admin Override Needed</strong><br>(Support views all data)</td>
                        <td>‚ö†Ô∏è Complex<br>Must disable/bypass RLS</td>
                        <td>‚úÖ Simple<br>Just don't filter</td>
                    </tr>
                </tbody>
            </table>

            <h2>üèóÔ∏è Recommended Architecture</h2>

            <div class="recommendation">
                <h3>Hybrid Security Model: RLS for Ownership + App Filtering for Access Control</h3>

                <div class="diagram">
                    <div class="layer db">
                        <strong>üîí Layer 1: RLS for User-Owned Data</strong>
                        <ul style="margin: 10px 0 0 20px;">
                            <li><code>keywords</code> ‚Üí RLS: <code>user_id = current_user_id</code></li>
                            <li><code>threat_keywords</code> ‚Üí RLS: <code>user_id = current_user_id OR is_default</code></li>
                            <li><code>user_source_preferences</code> ‚Üí RLS: <code>user_id = current_user_id</code></li>
                        </ul>
                    </div>

                    <div class="layer app">
                        <strong>üõ°Ô∏è Layer 2: Application Filtering for Shared Data</strong>
                        <ul style="margin: 10px 0 0 20px;">
                            <li><code>global_sources</code> ‚Üí App filter: <code>required_tier_level &lt;= user_tier</code></li>
                            <li><code>global_articles</code> ‚Üí App filter: Source + keyword matching</li>
                        </ul>
                    </div>

                    <div class="layer both">
                        <strong>‚öôÔ∏è Layer 3: Mandatory Validation Helpers</strong>
                        <ul style="margin: 10px 0 0 20px;">
                            <li><code>getSourcesForUser()</code> - Enforced via ESLint</li>
                            <li><code>validateSourceAccess()</code> - Called before mutations</li>
                            <li><code>canEnableSource()</code> - Checks tier + quantity limits</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h2>üíª Complete Implementation</h2>

            <div class="implementation-section">
                <h4>Step 1: Keep Current RLS for User-Owned Data</h4>
                <pre><code><span class="comment">// ‚úÖ KEEP: RLS for keywords (user-owned)</span>
<span class="keyword">export const</span> keywords = <span class="function">pgTable</span>(<span class="string">"keywords"</span>, {
  id: <span class="function">uuid</span>(<span class="string">"id"</span>).<span class="function">primaryKey</span>(),
  userId: <span class="function">uuid</span>(<span class="string">"user_id"</span>).<span class="function">references</span>(() => users.id),
  term: <span class="function">text</span>(<span class="string">"term"</span>),
}, (t) => [
  <span class="function">pgPolicy</span>(<span class="string">'keywords-rls'</span>, {
    <span class="keyword">for</span>: <span class="string">'all'</span>,
    using: sql<span class="string">`user_id::text = current_setting('app.current_user_id', true)`</span>
  })
]);</code></pre>
            </div>

            <div class="implementation-section">
                <h4>Step 2: Add RLS for user_source_preferences (Good Practice)</h4>
                <pre><code><span class="comment">// ‚úÖ ADD: RLS for user_source_preferences (user-owned junction)</span>
<span class="keyword">export const</span> userSourcePreferences = <span class="function">pgTable</span>(<span class="string">'user_source_preferences'</span>, {
  userId: <span class="function">uuid</span>(<span class="string">'user_id'</span>).<span class="function">notNull</span>(),
  sourceId: <span class="function">uuid</span>(<span class="string">'source_id'</span>).<span class="function">notNull</span>(),
  appContext: <span class="function">text</span>(<span class="string">'app_context'</span>).<span class="function">notNull</span>(),
  isEnabled: <span class="function">boolean</span>(<span class="string">'is_enabled'</span>).<span class="function">default</span>(<span class="keyword">true</span>),
}, (t) => [
  <span class="comment">// ‚úÖ This SHOULD have RLS - it's user-owned!</span>
  <span class="function">pgPolicy</span>(<span class="string">'user_preferences_rls'</span>, {
    <span class="keyword">for</span>: <span class="string">'all'</span>,
    using: sql<span class="string">`user_id::text = current_setting('app.current_user_id', true)`</span>,
    withCheck: sql<span class="string">`user_id::text = current_setting('app.current_user_id', true)`</span>
  })
]);</code></pre>
            </div>

            <div class="implementation-section">
                <h4>Step 3: NO RLS for global_sources (Shared Data)</h4>
                <pre><code><span class="comment">// ‚úÖ NO RLS: global_sources is shared data</span>
<span class="keyword">export const</span> globalSources = <span class="function">pgTable</span>(<span class="string">'global_sources'</span>, {
  id: <span class="function">uuid</span>(<span class="string">'id'</span>).<span class="function">primaryKey</span>(),
  name: <span class="function">text</span>(<span class="string">'name'</span>).<span class="function">notNull</span>(),
  requiredTierLevel: <span class="function">integer</span>(<span class="string">'required_tier_level'</span>).<span class="function">default</span>(<span class="number">0</span>),
  isActive: <span class="function">boolean</span>(<span class="string">'is_active'</span>).<span class="function">default</span>(<span class="keyword">true</span>),
  <span class="comment">// No userId - truly global!</span>
  <span class="comment">// No RLS policy - filter in application</span>
});</code></pre>
            </div>

            <div class="implementation-section">
                <h4>Step 4: Mandatory Helper Functions</h4>
                <pre><code><span class="comment">// backend/utils/source-access.ts</span>

<span class="comment">/**
 * Get sources available to user based on tier
 * SECURITY: Use this instead of querying global_sources directly
 */</span>
<span class="keyword">export async function</span> <span class="function">getAvailableSourcesForUser</span>(
  userId: <span class="keyword">string</span>,
  appContext: <span class="string">'news_radar'</span> | <span class="string">'threat_tracker'</span>
): <span class="keyword">Promise</span>&lt;GlobalSource[]&gt; {
  <span class="keyword">const</span> userTierLevel = <span class="keyword">await</span> <span class="function">getUserTierLevel</span>(userId);

  <span class="keyword">return</span> db
    .<span class="function">select</span>()
    .<span class="function">from</span>(globalSources)
    .<span class="function">where</span>(
      <span class="function">and</span>(
        <span class="function">eq</span>(globalSources.isActive, <span class="keyword">true</span>),
        <span class="function">lte</span>(globalSources.requiredTierLevel, userTierLevel)
      )
    );
}

<span class="comment">/**
 * Validate user can enable a source
 * SECURITY: Call before INSERT/UPDATE on user_source_preferences
 */</span>
<span class="keyword">export async function</span> <span class="function">canEnableSource</span>(
  userId: <span class="keyword">string</span>,
  sourceId: <span class="keyword">string</span>,
  appContext: <span class="string">'news_radar'</span> | <span class="string">'threat_tracker'</span>
): <span class="keyword">Promise</span>&lt;ValidationResult&gt; {
  <span class="comment">// 1. Check tier access</span>
  <span class="keyword">const</span> accessCheck = <span class="keyword">await</span> <span class="function">validateSourceAccess</span>(userId, sourceId);
  <span class="keyword">if</span> (!accessCheck.allowed) {
    <span class="keyword">return</span> accessCheck;
  }

  <span class="comment">// 2. Check quantity limit</span>
  <span class="keyword">const</span> limitCheck = <span class="keyword">await</span> <span class="function">checkSourceLimit</span>(userId, appContext);
  <span class="keyword">if</span> (!limitCheck.allowed) {
    <span class="keyword">return</span> limitCheck;
  }

  <span class="keyword">return</span> { allowed: <span class="keyword">true</span> };
}</code></pre>
            </div>

            <div class="implementation-section">
                <h4>Step 5: ESLint Rule to Enforce</h4>
                <pre><code><span class="comment">// .eslintrc.js or eslint.config.js</span>
{
  <span class="string">"rules"</span>: {
    <span class="string">"no-restricted-syntax"</span>: [
      <span class="string">"error"</span>,
      {
        <span class="string">"selector"</span>: <span class="string">"MemberExpression[object.name='db'][property.name='select'] ~ CallExpression[callee.property.name='from'] > Identifier[name='globalSources']"</span>,
        <span class="string">"message"</span>: <span class="string">"üö´ Direct queries to globalSources are not allowed. Use getAvailableSourcesForUser() instead."</span>
      }
    ]
  }
}</code></pre>
            </div>

            <h2>üß™ Testing Strategy</h2>

            <div class="implementation-section">
                <h4>Test RLS Policies</h4>
                <pre><code><span class="keyword">describe</span>(<span class="string">'RLS Policies'</span>, () => {
  <span class="function">test</span>(<span class="string">'keywords are isolated by user'</span>, <span class="keyword">async</span> () => {
    <span class="comment">// Set user context</span>
    <span class="keyword">await</span> <span class="function">withUserContext</span>(user1Id, <span class="keyword">async</span> (db) => {
      <span class="keyword">const</span> keywords = <span class="keyword">await</span> db.<span class="function">select</span>().<span class="function">from</span>(keywordsTable);
      <span class="comment">// Should only see user1's keywords</span>
      <span class="function">expect</span>(keywords.<span class="function">every</span>(k => k.userId === user1Id)).<span class="function">toBe</span>(<span class="keyword">true</span>);
    });
  });

  <span class="function">test</span>(<span class="string">'user_source_preferences are isolated'</span>, <span class="keyword">async</span> () => {
    <span class="keyword">await</span> <span class="function">withUserContext</span>(user1Id, <span class="keyword">async</span> (db) => {
      <span class="keyword">const</span> prefs = <span class="keyword">await</span> db.<span class="function">select</span>().<span class="function">from</span>(userSourcePreferences);
      <span class="function">expect</span>(prefs.<span class="function">every</span>(p => p.userId === user1Id)).<span class="function">toBe</span>(<span class="keyword">true</span>);
    });
  });
});</code></pre>
            </div>

            <div class="implementation-section">
                <h4>Test Application Filtering</h4>
                <pre><code><span class="keyword">describe</span>(<span class="string">'Tier-Based Source Filtering'</span>, () => {
  <span class="function">test</span>(<span class="string">'free user cannot access pro sources'</span>, <span class="keyword">async</span> () => {
    <span class="keyword">const</span> sources = <span class="keyword">await</span> <span class="function">getAvailableSourcesForUser</span>(freeUserId, <span class="string">'news_radar'</span>);
    <span class="function">expect</span>(sources.<span class="function">every</span>(s => s.requiredTierLevel === <span class="number">0</span>)).<span class="function">toBe</span>(<span class="keyword">true</span>);
  });

  <span class="function">test</span>(<span class="string">'pro user can access free and pro sources'</span>, <span class="keyword">async</span> () => {
    <span class="keyword">const</span> sources = <span class="keyword">await</span> <span class="function">getAvailableSourcesForUser</span>(proUserId, <span class="string">'news_radar'</span>);
    <span class="function">expect</span>(sources.<span class="function">some</span>(s => s.requiredTierLevel === <span class="number">0</span>)).<span class="function">toBe</span>(<span class="keyword">true</span>);
    <span class="function">expect</span>(sources.<span class="function">some</span>(s => s.requiredTierLevel === <span class="number">1</span>)).<span class="function">toBe</span>(<span class="keyword">true</span>);
  });

  <span class="function">test</span>(<span class="string">'cannot enable source above tier'</span>, <span class="keyword">async</span> () => {
    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="function">canEnableSource</span>(freeUserId, proSourceId, <span class="string">'news_radar'</span>);
    <span class="function">expect</span>(result.allowed).<span class="function">toBe</span>(<span class="keyword">false</span>);
    <span class="function">expect</span>(result.reason).<span class="function">toContain</span>(<span class="string">'tier'</span>);
  });
});</code></pre>
            </div>

            <h2>üìã Decision Matrix</h2>

            <table>
                <thead>
                    <tr>
                        <th>Table</th>
                        <th>Data Type</th>
                        <th>Use RLS?</th>
                        <th>Reasoning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>keywords</code></td>
                        <td>User-owned</td>
                        <td>‚úÖ Yes (current)</td>
                        <td>Each row belongs to one user</td>
                    </tr>
                    <tr>
                        <td><code>threat_keywords</code></td>
                        <td>User + defaults</td>
                        <td>‚úÖ Yes (current)</td>
                        <td>User-owned + shared defaults</td>
                    </tr>
                    <tr>
                        <td><code>user_source_preferences</code></td>
                        <td>User-owned</td>
                        <td>‚úÖ Yes (add)</td>
                        <td>Junction table with userId</td>
                    </tr>
                    <tr>
                        <td><code>global_sources</code></td>
                        <td>Shared with access rules</td>
                        <td>‚ùå No (app filter)</td>
                        <td>Global data, filter by tier in app</td>
                    </tr>
                    <tr>
                        <td><code>global_articles</code></td>
                        <td>Shared</td>
                        <td>‚ùå No (app filter)</td>
                        <td>Filtered by source preferences</td>
                    </tr>
                    <tr>
                        <td><code>subscription_tiers</code></td>
                        <td>Global config</td>
                        <td>‚ùå No</td>
                        <td>Public metadata</td>
                    </tr>
                </tbody>
            </table>

            <h2>‚úÖ Implementation Checklist</h2>

            <table>
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Task</th>
                        <th>Priority</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>1</strong></td>
                        <td>Keep existing RLS on <code>keywords</code></td>
                        <td><span class="badge">Done</span></td>
                    </tr>
                    <tr>
                        <td><strong>2</strong></td>
                        <td>Keep existing RLS on <code>threat_keywords</code></td>
                        <td><span class="badge">Done</span></td>
                    </tr>
                    <tr>
                        <td><strong>3</strong></td>
                        <td>Add RLS to <code>user_source_preferences</code></td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>4</strong></td>
                        <td>Do NOT add RLS to <code>global_sources</code></td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>5</strong></td>
                        <td>Create <code>source-access.ts</code> utility</td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>6</strong></td>
                        <td>Implement <code>getAvailableSourcesForUser()</code></td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>7</strong></td>
                        <td>Implement <code>canEnableSource()</code></td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>8</strong></td>
                        <td>Add ESLint rule to prevent direct queries</td>
                        <td><span class="badge warning">Medium</span></td>
                    </tr>
                    <tr>
                        <td><strong>9</strong></td>
                        <td>Update all API handlers to use helpers</td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                    <tr>
                        <td><strong>10</strong></td>
                        <td>Write unit tests for validation</td>
                        <td><span class="badge info">High</span></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <footer>
            <p>Generated by Claude Code | October 25, 2025</p>
            <p><strong>Final Recommendation:</strong> Option 3 - Application filtering for global_sources + RLS for user_source_preferences</p>
        </footer>
    </div>
</body>
</html>