// For simplified HTML, extract directly to a more processable format
    let links = [];
    let htmxLinks = [];
    let potentialArticleUrls = [];

    if (isSimplifiedHtml) {
      // Extract all links
      const linkRegex = /<a\s+href="([^"]*)"[^>]*>(.*?)<\/a>/gi;
      let match;
      const links = [];

      while ((match = linkRegex.exec(linksText)) !== null) {
        links.push({
          href: match[1],
          text: match[2].replace(/<[^>]+>/g, "").trim(), // Strip HTML from link text
        });
      }

      // Look for HTMX patterns
      const htmxPatterns = [
        { pattern: /\/media\/items\/.*-\d+\/?$/i, type: 'foojobs-article' },
        { pattern: /\/items\/[^/]+\/$/i, type: 'htmx-item' },
        { pattern: /\/articles?\/.*\d+/i, type: 'numbered-article' }
      ];

      // Perform initial pattern matching to identify likely article links
      links.forEach(link => {
        const url = link.href;
        const text = link.text;

        // Check for common article URL patterns
        const isArticleByUrl = 
          url.includes('/article/') || 
          url.includes('/blog/') || 
          url.includes('/news/') ||
          url.match(/\/(posts?|stories?|updates?)\//) ||
          url.match(/\d{4}\/\d{2}\//) || // Date pattern like /2023/05/
          url.match(/\/(cve|security|vulnerability|threat)-/) ||
          url.match(/\.com\/[^/]+\/[^/]+\/[^/]+/); // 3-level path like domain.com/section/topic/article-title

        // Check for article title patterns
        const isArticleByTitle = 
          text.length > 20 && // Longer titles are often articles
          (
            text.includes(': ') || // Title pattern with colon
            text.match(/^(how|why|what|when)\s+/i) || // "How to..." titles
            text.match(/[â€”\-\|]\s/) // Title with separator
          );

        // Check for security keywords in title
        const securityKeywords = ['security', 'cyber', 'hack', 'threat', 'vulnerability', 'breach', 'attack', 'malware', 'phishing', 'ransomware'];
        const hasSecurityKeyword = securityKeywords.some(keyword => 
          text.toLowerCase().includes(keyword)
        );

        // Check if URL matches HTMX patterns
        const htmxMatch = htmxPatterns.find(pattern => url.match(pattern.pattern));
        if (htmxMatch) {
          htmxLinks.push({
            href: url,
            text: text,
            pattern: htmxMatch.type
          });

          // Auto-include links that match specific HTMX patterns (like FooJobs)
          if (htmxMatch.type === 'foojobs-article' || url.includes('/media/items/')) {
            potentialArticleUrls.push(url);
            log(`[ThreatTracker] Auto-detected HTMX article: ${url}`, "openai");
          }
        }

        // Include article-like links for AI processing
        if (isArticleByUrl || isArticleByTitle || hasSecurityKeyword) {
          // For article URLs that don't match specific patterns, we'll let the AI evaluate them
          if (!potentialArticleUrls.includes(url)) {
            potentialArticleUrls.push(url);
          }
        }
      });

      // Log information about the processing
      log(`[ThreatTracker] Extracted ${links.length} total links`, "openai");
      log(`[ThreatTracker] Found ${htmxLinks.length} potential HTMX links`, "openai");
      log(`[ThreatTracker] Identified ${potentialArticleUrls.length} potential article URLs through pattern matching`, "openai");

      // If we found HTMX article links, prioritize those and skip AI processing in some cases
      if (htmxLinks.length > 0 && htmxLinks.some(link => link.pattern === 'foojobs-article')) {
        log(`[ThreatTracker] FooJobs article pattern detected, using HTMX-specific handling`, "openai");

        // Return immediately if we found enough HTMX articles
        if (potentialArticleUrls.length >= 5) {
          log(`[ThreatTracker] Found ${potentialArticleUrls.length} FooJobs articles via pattern matching`, "openai");
          return potentialArticleUrls;
        }
      }

      // Convert links to format for AI processing
      linksText = links
        .map((link) => `URL: ${link.href}, Text: ${link.text}`)
        .join("\n");
    }